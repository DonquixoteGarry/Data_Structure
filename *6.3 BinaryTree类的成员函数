/*

编写二叉树类(Binary tree)的成员函数，分别实现以下功能：

1.统计二叉树的叶节点的数目

2.交换二叉树中所有节点的左右子树

3.按层次顺序遍历二叉树：首先访问根节点，然后是它的两个孩子节点，然后是孙子节点，依此类推

4.求二叉树的宽度，即同一层次上最多的节点数

要求:
以任意可行的方式输入一棵二叉树，程序依次显示上述各项处理的结果

*/




#include<iostream>
#include<cstring>
#include<iomanip>
using namespace std;
class binaryTreeNode
{
public:
	char value;
	int depth;//depth深度,根节点深度为0
	binaryTreeNode* leftchild;
	binaryTreeNode* rightchild;
	binaryTreeNode* thefather;
	bool isroot;
	binaryTreeNode()
	{
		leftchild = NULL;
		rightchild = NULL;
		isroot = false;
		thefather = NULL;
		depth = 0;
		value = 0;
	}
	void node_push(char new_value)
	{

		value = new_value;
	}
	void branch()
		//生成空值左右子树
	{
		leftchild = new binaryTreeNode;
		rightchild = new binaryTreeNode;
	}
	void rootlize()
		//树根化
	{
		isroot = true;
	}
	void visit()
		//访问
	{
		cout << setw(long long int(depth) * 4) << value << endl;
	}
	void print_all_subtree()
	{
		//右根左遍历二叉树
		if (rightchild != NULL)rightchild->print_all_subtree();
		visit();
		if (leftchild != NULL)leftchild->print_all_subtree();
		return;
	}
};
void leaf_count(binaryTreeNode* _root, int counter_num)
{//单节点全叶节点统计
	if (_root->rightchild != NULL)leaf_count(_root->rightchild, counter_num);
	if ((_root->rightchild == NULL) && (_root->leftchild == NULL))
	{
		counter_num++;
	}
	if (_root->leftchild != NULL)leaf_count(_root->leftchild, counter_num);
	return ;
}
void swap_all(binaryTreeNode* _root)
{
	if ((_root->rightchild != NULL) && (_root->leftchild == NULL))
	{
		_root->leftchild = _root->rightchild;
		_root->rightchild = NULL;
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		binaryTreeNode* new_one = _root->leftchild;
		_root->leftchild = _root->rightchild;
		_root->rightchild =new_one;
		free(new_one);
	}
	if ((_root->rightchild == NULL) && (_root->leftchild != NULL))
	{
		_root->rightchild = _root->leftchild;
		_root->leftchild = NULL;
	}
}
void get_deepest(binaryTreeNode* _root, int the_deepest)
{
	if (_root->rightchild != NULL)
	{
		get_deepest(_root->rightchild, the_deepest);
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		if (_root->depth > the_deepest)the_deepest = _root->depth;
	}
	if (_root->leftchild != NULL)
	{
		get_deepest(_root->leftchild, the_deepest);
	}
}
void print_in_order_of_depth(binaryTreeNode* _root, int goal_depth)
{
	if (_root->rightchild != NULL)
	{
		print_in_order_of_depth(_root->rightchild, goal_depth);
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		if (_root->depth == goal_depth)
		{
			cout << _root->value << "  ";
		}
	}
	if (_root->leftchild != NULL)
	{
		print_in_order_of_depth(_root->leftchild, goal_depth);
	}
}
void get_width_of_depth(binaryTreeNode* _root, int _width,int _depth)
{
	if (_root->rightchild != NULL)
	{
		get_width_of_depth(_root->rightchild, _width, _depth);
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		if (_root->depth == _depth)
		{
			_width++;
		}
	}
	if (_root->leftchild != NULL)
	{
		get_width_of_depth(_root->leftchild, _width, _depth);
	}
}
class binaryTree
{
public:
	binaryTreeNode* root;
	binaryTree() { root = NULL; }
	void tree_leaf_count()
	{
		cout << "----------开始统计叶节点数----------\n";
		int the_counter_num=0;
		leaf_count(root, the_counter_num);
		cout << "叶节点数为:"<< the_counter_num <<"\n";
		cout << "----------叶节点数统计完毕----------\n";
		return ;
	}
	void tree_swap_all()
	{
		swap_all(root);
	}
	void print_by_depth()
	{
		int the_depth=0;
		get_deepest(root, the_depth);
		cout << "----------开始按层次遍历----------\n";
		for (int i = 0; i <= the_depth; i++)
		{
			cout << "深度为" << the_depth << " ";
			print_in_order_of_depth(root, i);
			cout << endl;
		}
		cout << "----------层次遍历结束----------\n";
	}
	void get_width()
	{
		int max_width,max_depth;
		max_width = 0;
		max_depth = 0;
		get_deepest(root, max_depth);
		cout << "----------开始求二叉树宽度----------\n";
		for (int i = 0; i <= max_depth; i++)
		{
			int new_width;
			new_width = 0;
			get_width_of_depth(root, new_width, i);
			if (new_width > max_width)max_width = new_width;
		}
		cout << "二叉树宽度为" << max_width << endl;
		cout << "----------宽度求值结束----------\n";
	}
	void tree_print()
	{
		cout << "\n----------开始打印二叉树----------\n";
		root->print_all_subtree();
		cout << "\n----------二叉树打印完毕----------\n";
	}
};
void build_tree(binaryTree _tree, char* value_list)
{
	int s = 0;
	//作为字符串中工作位置的字符的下标s
	binaryTreeNode* work_node = _tree.root;
	//作为二叉树中工作位置的节点的指针work_node
	int _len = strlen(value_list);
	_tree.root = new binaryTreeNode;
	_tree.root->rootlize();
	work_node->node_push(value_list[s]);
	s++;
	while (s<_len)//最后一位下标为_len-1
	{
	/*	if (s < _len - 2)
		{
			work_node = work_node->leftchild;
			work_node->node_push(value_list[s]);
			s++;
			work_node = work_node->thefather->rightchild;
			work_node->node_push(value_list[s]);
			s++;
		}
	*/
	}
}
int main()
{
	binaryTree tree1;
	char* _value_list=new char[100];
	cin >> _value_list;
	build_tree(tree1, _value_list);
	char op;
	cout << "\n0:程序结束\n1:统计叶节点\n2:全子树交换\n3:按层次遍历\n4:求全树宽度\n5:全树打印\n\n";
	cin >> op;
	while (1)
	{
		switch (op)
		{
		case'0':
			return 0;
		case'1':
			tree1.tree_leaf_count();
			break;
		case'2':
			tree1.tree_swap_all();
			break;
		case'3':
			tree1.print_by_depth();
			break;
		case'4':
			tree1.get_width();
			break;
		case'5':
			tree1.tree_print();
			break;
		default:
			cout << "\n非法输入!\n";
			break;
		}
	}
}

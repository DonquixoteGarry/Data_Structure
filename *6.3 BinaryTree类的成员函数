/*

编写二叉树类(Binary tree)的成员函数，分别实现以下功能：

1.统计二叉树的叶节点的数目

2.交换二叉树中所有节点的左右子树

3.按层次顺序遍历二叉树：首先访问根节点，然后是它的两个孩子节点，然后是孙子节点，依此类推

4.求二叉树的宽度，即同一层次上最多的节点数

要求:
以任意可行的方式输入一棵二叉树，程序依次显示上述各项处理的结果

*/


/*
二叉树建树branch函数未完成
*/

#include<iostream>
#include<cstring>
#include<iomanip>
using namespace std;
class binaryTreeNode
{
public:
	char value;
	int depth;//depth深度,根节点深度为0
	binaryTreeNode* leftchild;
	binaryTreeNode* rightchild;
	binaryTreeNode* thefather;
	bool isroot;
	binaryTreeNode()
	{
		leftchild = NULL;
		rightchild = NULL;
		isroot = false;
		thefather = NULL;
		depth = -1;
		value = 0;
	}
	void node_push(char new_value)
	{

		value = new_value;
	}
	void rootlize()
		//树根化
	{
		isroot = true;
		depth = 0;
	}
	void visit()
		//访问
	{
		cout << setw(long long int(depth) * 4) << value << endl;
	}
	void print_all_subtree()
	{
		//右根左遍历二叉树
		if (rightchild != NULL)rightchild->print_all_subtree();
		visit();
		if (leftchild != NULL)leftchild->print_all_subtree();
		return;
	}
	bool isleft()
	{//是否为leftchild
		if (thefather->leftchild == this)return true;
		else return false;
	}
	bool isright()
	{//是否为rightchild
		if (thefather->rightchild == this)return true;
		else return false;
	}
};
void branch(binaryTreeNode* _root, char* char_list, int _position)
{
	//用所给字符串在树根上按先序遍历(根左右)顺序建立二叉树
	//用字符'0'直接建立叶节点'0',用字符'#'结束总进程
	//_position初始值为0
	binaryTreeNode* work_node = _root;
	while(1)
	{
		work_node->node_push(char_list[_position]);
		if (char_list[_position] == '#')return;
		if ((char_list[_position] == '0') && (work_node->isleft() == true))
		{

		}
	}

}
void leaf_count(binaryTreeNode* _root, int counter_num)
{//单节点子树全叶节点统计
	if (_root->rightchild != NULL)leaf_count(_root->rightchild, counter_num);
	if ((_root->rightchild == NULL) && (_root->leftchild == NULL))
	{
		counter_num++;
	}
	if (_root->leftchild != NULL)leaf_count(_root->leftchild, counter_num);
}
void swap_all(binaryTreeNode* _root)
{//单节点全子树交换
	if ((_root->rightchild != NULL) && (_root->leftchild == NULL))
	{
		_root->leftchild = _root->rightchild;
		_root->rightchild = NULL;
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		binaryTreeNode* new_one = _root->leftchild;
		_root->leftchild = _root->rightchild;
		_root->rightchild =new_one;
		free(new_one);
	}
	if ((_root->rightchild == NULL) && (_root->leftchild != NULL))
	{
		_root->rightchild = _root->leftchild;
		_root->leftchild = NULL;
	}
}
void get_deepest(binaryTreeNode* _root, int the_deepest)
{//单节点全子树最大深度求解
	if (_root->rightchild != NULL)
	{
		get_deepest(_root->rightchild, the_deepest);
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		if (_root->depth > the_deepest)the_deepest = _root->depth;
	}
	if (_root->leftchild != NULL)
	{
		get_deepest(_root->leftchild, the_deepest);
	}
}
void print_in_order_of_depth(binaryTreeNode* _root, int goal_depth)
{//单节点全子树特定深度节点输出
	if (_root->rightchild != NULL)
	{
		print_in_order_of_depth(_root->rightchild, goal_depth);
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		if (_root->depth == goal_depth)
		{
			cout << _root->value << "  ";
		}
	}
	if (_root->leftchild != NULL)
	{
		print_in_order_of_depth(_root->leftchild, goal_depth);
	}
}
void get_width_of_depth(binaryTreeNode* _root, int _width,int _depth)
{//单节点全子树特定深度节点数目统计
	if (_root->rightchild != NULL)
	{
		get_width_of_depth(_root->rightchild, _width, _depth);
	}
	if ((_root->rightchild != NULL) && (_root->leftchild != NULL))
	{
		if (_root->depth == _depth)
		{
			_width++;
		}
	}
	if (_root->leftchild != NULL)
	{
		get_width_of_depth(_root->leftchild, _width, _depth);
	}
}
class binaryTree
{
public:
	binaryTreeNode* root;
	binaryTree() { root = NULL; }
	void tree_leaf_count()
	{
		cout << "----------开始统计叶节点数----------\n";
		int the_counter_num=0;
		leaf_count(root, the_counter_num);
		cout << "叶节点数为:"<< the_counter_num <<"\n";
		cout << "----------叶节点数统计完毕----------\n";
		return ;
	}
	void tree_swap_all()
	{
		swap_all(root);
		return;
	}
	void print_by_depth()
	{
		int the_depth=0;
		get_deepest(root, the_depth);
		cout << "----------开始按层次遍历----------\n";
		for (int i = 0; i <= the_depth; i++)
		{
			cout << "深度为" << the_depth << " ";
			print_in_order_of_depth(root, i);
			cout << endl;
		}
		cout << "----------层次遍历结束----------\n";
	}
	void get_width()
	{
		int max_width,max_depth;
		max_width = 0;
		max_depth = 0;
		get_deepest(root, max_depth);
		cout << "----------开始求二叉树宽度----------\n";
		for (int i = 0; i <= max_depth; i++)
		{
			int new_width;
			new_width = 0;
			get_width_of_depth(root, new_width, i);
			if (new_width > max_width)max_width = new_width;
		}
		cout << "二叉树宽度为" << max_width << endl;
		cout << "----------宽度求值结束----------\n";
	}
	void build_tree(char* value_list)
	{
		cout << "\n----------开始建立二叉树----------\n";
		branch(root, value_list, 0);
		cout << "\n----------二叉树建立完毕----------\n";
	}
	void tree_print()
	{
		cout << "\n----------开始打印二叉树----------\n";
		root->print_all_subtree();
		cout << "\n----------二叉树打印完毕----------\n";
	}
};
int main()
{
	binaryTree tree1;
	char* _value_list=new char[100];
	cin >> _value_list;
	tree1.build_tree(_value_list);
	char op;
	cout << "\n0:程序结束\n1:统计叶节点\n2:全子树交换\n3:按层次遍历\n4:求全树宽度\n5:全树打印\n\n";
	cin >> op;
	while (1)
	{
		switch (op)
		{
		case'0':
			return 0;
		case'1':
			tree1.tree_leaf_count();
			break;
		case'2':
			tree1.tree_swap_all();
			break;
		case'3':
			tree1.print_by_depth();
			break;
		case'4':
			tree1.get_width();
			break;
		case'5':
			tree1.tree_print();
			break;
		default:
			cout << "\n非法输入!\n";
			break;
		}
	}
}
			
